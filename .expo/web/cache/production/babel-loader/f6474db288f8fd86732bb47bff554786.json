{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import{EventTypes}from\"../interfaces\";var RotationGestureDetector=function(){function RotationGestureDetector(callbacks){_classCallCheck(this,RotationGestureDetector);_defineProperty(this,\"onRotationBegin\",void 0);_defineProperty(this,\"onRotation\",void 0);_defineProperty(this,\"onRotationEnd\",void 0);_defineProperty(this,\"currentTime\",0);_defineProperty(this,\"previousTime\",0);_defineProperty(this,\"previousAngle\",0);_defineProperty(this,\"rotation\",0);_defineProperty(this,\"anchorX\",0);_defineProperty(this,\"anchorY\",0);_defineProperty(this,\"isInProgress\",false);_defineProperty(this,\"keyPointers\",[NaN,NaN]);this.onRotationBegin=callbacks.onRotationBegin;this.onRotation=callbacks.onRotation;this.onRotationEnd=callbacks.onRotationEnd;}_createClass(RotationGestureDetector,[{key:\"updateCurrent\",value:function updateCurrent(event,tracker){this.previousTime=this.currentTime;this.currentTime=event.time;var _this$keyPointers=_slicedToArray(this.keyPointers,2),firstPointerID=_this$keyPointers[0],secondPointerID=_this$keyPointers[1];var firstPointerX=tracker.getLastX(firstPointerID);var firstPointerY=tracker.getLastY(firstPointerID);var secondPointerX=tracker.getLastX(secondPointerID);var secondPointerY=tracker.getLastY(secondPointerID);var vectorX=secondPointerX-firstPointerX;var vectorY=secondPointerY-firstPointerY;this.anchorX=(firstPointerX+secondPointerX)/2;this.anchorY=(firstPointerY+secondPointerY)/2;var angle=-Math.atan2(vectorY,vectorX);this.rotation=Number.isNaN(this.previousAngle)?0:this.previousAngle-angle;this.previousAngle=angle;if(this.rotation>Math.PI){this.rotation-=Math.PI;}else if(this.rotation<-Math.PI){this.rotation+=Math.PI;}if(this.rotation>Math.PI/2){this.rotation-=Math.PI;}else if(this.rotation<-Math.PI/2){this.rotation+=Math.PI;}}},{key:\"finish\",value:function finish(){if(!this.isInProgress){return;}this.isInProgress=false;this.keyPointers=[NaN,NaN];this.onRotationEnd(this);}},{key:\"setKeyPointers\",value:function setKeyPointers(tracker){if(this.keyPointers[0]&&this.keyPointers[1]){return;}var pointerIDs=tracker.getData().keys();this.keyPointers[0]=pointerIDs.next().value;this.keyPointers[1]=pointerIDs.next().value;}},{key:\"onTouchEvent\",value:function onTouchEvent(event,tracker){switch(event.eventType){case EventTypes.DOWN:this.isInProgress=false;break;case EventTypes.ADDITIONAL_POINTER_DOWN:if(this.isInProgress){break;}this.isInProgress=true;this.previousTime=event.time;this.previousAngle=NaN;this.setKeyPointers(tracker);this.updateCurrent(event,tracker);this.onRotationBegin(this);break;case EventTypes.MOVE:if(!this.isInProgress){break;}this.updateCurrent(event,tracker);this.onRotation(this);break;case EventTypes.ADDITIONAL_POINTER_UP:if(!this.isInProgress){break;}if(this.keyPointers.indexOf(event.pointerId)>=0){this.finish();}break;case EventTypes.UP:if(this.isInProgress){this.finish();}break;}return true;}},{key:\"getTimeDelta\",value:function getTimeDelta(){return this.currentTime+this.previousTime;}},{key:\"getAnchorX\",value:function getAnchorX(){return this.anchorX;}},{key:\"getAnchorY\",value:function getAnchorY(){return this.anchorY;}},{key:\"getRotation\",value:function getRotation(){return this.rotation;}},{key:\"reset\",value:function reset(){this.keyPointers=[NaN,NaN];this.isInProgress=false;}}]);return RotationGestureDetector;}();export{RotationGestureDetector as default};","map":{"version":3,"sources":["RotationGestureDetector.ts"],"names":["constructor","callbacks","updateCurrent","event","firstPointerX","tracker","firstPointerY","secondPointerX","secondPointerY","vectorX","vectorY","angle","Math","Number","finish","setKeyPointers","pointerIDs","onTouchEvent","EventTypes","getTimeDelta","getAnchorX","getAnchorY","getRotation","reset"],"mappings":"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","sourcesContent":["import { AdaptedEvent, EventTypes } from '../interfaces';\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface RotationGestureListener {\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n}\n\nexport default class RotationGestureDetector\n  implements RotationGestureListener\n{\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n\n  private currentTime = 0;\n  private previousTime = 0;\n\n  private previousAngle = 0;\n  private rotation = 0;\n\n  private anchorX = 0;\n  private anchorY = 0;\n\n  private isInProgress = false;\n\n  private keyPointers: number[] = [NaN, NaN];\n\n  constructor(callbacks: RotationGestureListener) {\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n\n  private updateCurrent(event: AdaptedEvent, tracker: PointerTracker): void {\n    this.previousTime = this.currentTime;\n    this.currentTime = event.time;\n\n    const [firstPointerID, secondPointerID] = this.keyPointers;\n\n    const firstPointerX: number = tracker.getLastX(firstPointerID);\n    const firstPointerY: number = tracker.getLastY(firstPointerID);\n    const secondPointerX: number = tracker.getLastX(secondPointerID);\n    const secondPointerY: number = tracker.getLastY(secondPointerID);\n\n    const vectorX: number = secondPointerX - firstPointerX;\n    const vectorY: number = secondPointerY - firstPointerY;\n\n    this.anchorX = (firstPointerX + secondPointerX) / 2;\n    this.anchorY = (firstPointerY + secondPointerY) / 2;\n\n    //Angle diff should be positive when rotating in clockwise direction\n    const angle: number = -Math.atan2(vectorY, vectorX);\n\n    this.rotation = Number.isNaN(this.previousAngle)\n      ? 0\n      : this.previousAngle - angle;\n\n    this.previousAngle = angle;\n\n    if (this.rotation > Math.PI) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI) {\n      this.rotation += Math.PI;\n    }\n\n    if (this.rotation > Math.PI / 2) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI / 2) {\n      this.rotation += Math.PI;\n    }\n  }\n\n  private finish(): void {\n    if (!this.isInProgress) {\n      return;\n    }\n\n    this.isInProgress = false;\n    this.keyPointers = [NaN, NaN];\n    this.onRotationEnd(this);\n  }\n\n  private setKeyPointers(tracker: PointerTracker): void {\n    if (this.keyPointers[0] && this.keyPointers[1]) {\n      return;\n    }\n\n    const pointerIDs: IterableIterator<number> = tracker.getData().keys();\n\n    this.keyPointers[0] = pointerIDs.next().value as number;\n    this.keyPointers[1] = pointerIDs.next().value as number;\n  }\n\n  public onTouchEvent(event: AdaptedEvent, tracker: PointerTracker): boolean {\n    switch (event.eventType) {\n      case EventTypes.DOWN:\n        this.isInProgress = false;\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_DOWN:\n        if (this.isInProgress) {\n          break;\n        }\n        this.isInProgress = true;\n\n        this.previousTime = event.time;\n        this.previousAngle = NaN;\n\n        this.setKeyPointers(tracker);\n\n        this.updateCurrent(event, tracker);\n        this.onRotationBegin(this);\n        break;\n\n      case EventTypes.MOVE:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        this.updateCurrent(event, tracker);\n        this.onRotation(this);\n\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_UP:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n          this.finish();\n        }\n\n        break;\n\n      case EventTypes.UP:\n        if (this.isInProgress) {\n          this.finish();\n        }\n        break;\n    }\n\n    return true;\n  }\n\n  public getTimeDelta(): number {\n    return this.currentTime + this.previousTime;\n  }\n\n  public getAnchorX(): number {\n    return this.anchorX;\n  }\n\n  public getAnchorY(): number {\n    return this.anchorY;\n  }\n\n  public getRotation(): number {\n    return this.rotation;\n  }\n\n  public reset(): void {\n    this.keyPointers = [NaN, NaN];\n    this.isInProgress = false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}