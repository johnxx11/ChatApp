{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import{State}from\"../../State\";import{PointerType}from\"../interfaces\";import PointerTracker from\"./PointerTracker\";import{isPointerInBounds}from\"../utils\";var GestureHandlerOrchestrator=function(){function GestureHandlerOrchestrator(){_classCallCheck(this,GestureHandlerOrchestrator);_defineProperty(this,\"gestureHandlers\",[]);_defineProperty(this,\"awaitingHandlers\",[]);_defineProperty(this,\"handlersToCancel\",[]);_defineProperty(this,\"handlingChangeSemaphore\",0);_defineProperty(this,\"activationIndex\",0);}_createClass(GestureHandlerOrchestrator,[{key:\"scheduleFinishedHandlersCleanup\",value:function scheduleFinishedHandlersCleanup(){if(this.handlingChangeSemaphore===0){this.cleanupFinishedHandlers();}}},{key:\"cleanHandler\",value:function cleanHandler(handler){handler.reset();handler.setActive(false);handler.setAwaiting(false);handler.setActivationIndex(Number.MAX_VALUE);}},{key:\"removeHandlerFromOrchestrator\",value:function removeHandlerFromOrchestrator(handler){this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler),1);this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler),1);this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler),1);}},{key:\"cleanupFinishedHandlers\",value:function cleanupFinishedHandlers(){for(var i=this.gestureHandlers.length-1;i>=0;--i){var handler=this.gestureHandlers[i];if(!handler){continue;}if(this.isFinished(handler.getState())&&!handler.isAwaiting()){this.gestureHandlers.splice(i,1);this.cleanHandler(handler);}}}},{key:\"hasOtherHandlerToWaitFor\",value:function hasOtherHandlerToWaitFor(handler){var _this=this;var hasToWait=false;this.gestureHandlers.forEach(function(otherHandler){if(otherHandler&&!_this.isFinished(otherHandler.getState())&&_this.shouldHandlerWaitForOther(handler,otherHandler)){hasToWait=true;return;}});return hasToWait;}},{key:\"tryActivate\",value:function tryActivate(handler){if(this.hasOtherHandlerToWaitFor(handler)){this.addAwaitingHandler(handler);}else if(handler.getState()!==State.CANCELLED&&handler.getState()!==State.FAILED){if(this.shouldActivate(handler)){this.makeActive(handler);}else{switch(handler.getState()){case State.ACTIVE:handler.fail();break;case State.BEGAN:handler.cancel();}}}}},{key:\"shouldActivate\",value:function shouldActivate(handler){for(var otherHandler of this.gestureHandlers){if(this.shouldHandlerBeCancelledBy(handler,otherHandler)){return false;}}return true;}},{key:\"cleanupAwaitingHandlers\",value:function cleanupAwaitingHandlers(handler){for(var i=0;i<this.awaitingHandlers.length;++i){if(!this.awaitingHandlers[i].isAwaiting()&&this.shouldHandlerWaitForOther(this.awaitingHandlers[i],handler)){this.cleanHandler(this.awaitingHandlers[i]);this.awaitingHandlers.splice(i,1);}}}},{key:\"onHandlerStateChange\",value:function onHandlerStateChange(handler,newState,oldState,sendIfDisabled){var _this2=this;if(!handler.isEnabled()&&!sendIfDisabled){return;}this.handlingChangeSemaphore+=1;if(this.isFinished(newState)){this.awaitingHandlers.forEach(function(otherHandler){if(_this2.shouldHandlerWaitForOther(otherHandler,handler)){if(newState===State.END){otherHandler===null||otherHandler===void 0?void 0:otherHandler.cancel();if(otherHandler.getState()===State.END){otherHandler.sendEvent(State.CANCELLED,State.BEGAN);}otherHandler===null||otherHandler===void 0?void 0:otherHandler.setAwaiting(false);}else{_this2.tryActivate(otherHandler);}}});}if(newState===State.ACTIVE){this.tryActivate(handler);}else if(oldState===State.ACTIVE||oldState===State.END){if(handler.isActive()){handler.sendEvent(newState,oldState);}else if(oldState===State.ACTIVE&&(newState===State.CANCELLED||newState===State.FAILED)){handler.sendEvent(newState,State.BEGAN);}}else if(oldState!==State.UNDETERMINED||newState!==State.CANCELLED){handler.sendEvent(newState,oldState);}this.handlingChangeSemaphore-=1;this.scheduleFinishedHandlersCleanup();if(this.awaitingHandlers.indexOf(handler)<0){this.cleanupAwaitingHandlers(handler);}}},{key:\"makeActive\",value:function makeActive(handler){var _this3=this;var currentState=handler.getState();handler.setActive(true);handler.setShouldResetProgress(true);handler.setActivationIndex(this.activationIndex++);this.gestureHandlers.forEach(function(otherHandler){if(_this3.shouldHandlerBeCancelledBy(otherHandler,handler)){_this3.handlersToCancel.push(otherHandler);}});for(var i=this.handlersToCancel.length-1;i>=0;--i){var _this$handlersToCance;(_this$handlersToCance=this.handlersToCancel[i])===null||_this$handlersToCance===void 0?void 0:_this$handlersToCance.cancel();}this.awaitingHandlers.forEach(function(otherHandler){if(_this3.shouldHandlerBeCancelledBy(otherHandler,handler)){otherHandler===null||otherHandler===void 0?void 0:otherHandler.cancel();otherHandler===null||otherHandler===void 0?void 0:otherHandler.setAwaiting(true);}});handler.sendEvent(State.ACTIVE,State.BEGAN);if(currentState!==State.ACTIVE){handler.sendEvent(State.END,State.ACTIVE);if(currentState!==State.END){handler.sendEvent(State.UNDETERMINED,State.END);}}if(handler.isAwaiting()){handler.setAwaiting(false);for(var _i2=0;_i2<this.awaitingHandlers.length;++_i2){if(this.awaitingHandlers[_i2]===handler){this.awaitingHandlers.splice(_i2,1);}}}this.handlersToCancel=[];}},{key:\"addAwaitingHandler\",value:function addAwaitingHandler(handler){var alreadyExists=false;this.awaitingHandlers.forEach(function(otherHandler){if(otherHandler===handler){alreadyExists=true;return;}});if(alreadyExists){return;}this.awaitingHandlers.push(handler);handler.setAwaiting(true);handler.setActivationIndex(this.activationIndex++);}},{key:\"recordHandlerIfNotPresent\",value:function recordHandlerIfNotPresent(handler){var alreadyExists=false;this.gestureHandlers.forEach(function(otherHandler){if(otherHandler===handler){alreadyExists=true;return;}});if(alreadyExists){return;}this.gestureHandlers.push(handler);handler.setActive(false);handler.setAwaiting(false);handler.setActivationIndex(Number.MAX_SAFE_INTEGER);}},{key:\"shouldHandlerWaitForOther\",value:function shouldHandlerWaitForOther(handler,otherHandler){return handler!==otherHandler&&(handler.shouldWaitForHandlerFailure(otherHandler)||otherHandler.shouldRequireToWaitForFailure(handler));}},{key:\"canRunSimultaneously\",value:function canRunSimultaneously(gh1,gh2){return gh1===gh2||gh1.shouldRecognizeSimultaneously(gh2)||gh2.shouldRecognizeSimultaneously(gh1);}},{key:\"shouldHandlerBeCancelledBy\",value:function shouldHandlerBeCancelledBy(handler,otherHandler){if(this.canRunSimultaneously(handler,otherHandler)){return false;}if(handler!==otherHandler&&(handler.isAwaiting()||handler.getState()===State.ACTIVE)){return handler.shouldBeCancelledByOther(otherHandler);}var handlerPointers=handler.getTrackedPointersID();var otherPointers=otherHandler.getTrackedPointersID();if(!PointerTracker.shareCommonPointers(handlerPointers,otherPointers)&&handler.getView()!==otherHandler.getView()){return this.checkOverlap(handler,otherHandler);}return true;}},{key:\"checkOverlap\",value:function checkOverlap(handler,otherHandler){var handlerPointers=handler.getTrackedPointersID();var otherPointers=otherHandler.getTrackedPointersID();var overlap=false;handlerPointers.forEach(function(pointer){var handlerX=handler.getTracker().getLastX(pointer);var handlerY=handler.getTracker().getLastY(pointer);if(isPointerInBounds(handler.getView(),{x:handlerX,y:handlerY})&&isPointerInBounds(otherHandler.getView(),{x:handlerX,y:handlerY})){overlap=true;}});otherPointers.forEach(function(pointer){var otherX=otherHandler.getTracker().getLastX(pointer);var otherY=otherHandler.getTracker().getLastY(pointer);if(isPointerInBounds(handler.getView(),{x:otherX,y:otherY})&&isPointerInBounds(otherHandler.getView(),{x:otherX,y:otherY})){overlap=true;}});return overlap;}},{key:\"isFinished\",value:function isFinished(state){return state===State.END||state===State.FAILED||state===State.CANCELLED;}},{key:\"cancelMouseAndPenGestures\",value:function cancelMouseAndPenGestures(currentHandler){this.gestureHandlers.forEach(function(handler){if(handler.getPointerType()!==PointerType.MOUSE&&handler.getPointerType()!==PointerType.PEN){return;}if(handler!==currentHandler){handler.cancel();}else{handler.getTracker().resetTracker();}});}}],[{key:\"getInstance\",value:function getInstance(){if(!GestureHandlerOrchestrator.instance){GestureHandlerOrchestrator.instance=new GestureHandlerOrchestrator();}return GestureHandlerOrchestrator.instance;}}]);return GestureHandlerOrchestrator;}();export{GestureHandlerOrchestrator as default};_defineProperty(GestureHandlerOrchestrator,\"instance\",void 0);","map":{"version":3,"sources":["GestureHandlerOrchestrator.ts"],"names":["GestureHandlerOrchestrator","constructor","scheduleFinishedHandlersCleanup","cleanHandler","handler","Number","removeHandlerFromOrchestrator","cleanupFinishedHandlers","i","hasOtherHandlerToWaitFor","hasToWait","otherHandler","tryActivate","State","shouldActivate","cleanupAwaitingHandlers","onHandlerStateChange","newState","oldState","makeActive","currentState","addAwaitingHandler","alreadyExists","recordHandlerIfNotPresent","shouldHandlerWaitForOther","canRunSimultaneously","gh1","gh2","shouldHandlerBeCancelledBy","handlerPointers","otherPointers","PointerTracker","checkOverlap","overlap","pointer","handlerX","handlerY","x","y","isPointerInBounds","otherX","otherY","isFinished","state","cancelMouseAndPenGestures","PointerType","getInstance"],"mappings":"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","sourcesContent":["import { State } from '../../State';\nimport { PointerType } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\nimport { isPointerInBounds } from '../utils';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n  private handlersToCancel: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: GestureHandler): void {\n    this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n    this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n    this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (!handler) {\n        continue;\n      }\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(handler: GestureHandler): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else if (\n      handler.getState() !== State.CANCELLED &&\n      handler.getState() !== State.FAILED\n    ) {\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n      } else {\n        switch (handler.getState()) {\n          case State.ACTIVE:\n            handler.fail();\n            break;\n          case State.BEGAN:\n            handler.cancel();\n        }\n      }\n    }\n  }\n\n  private shouldActivate(handler: GestureHandler): boolean {\n    for (const otherHandler of this.gestureHandlers) {\n      if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel();\n            if (otherHandler.getState() === State.END) {\n              // Handle edge case, where discrete gestures end immediately after activation thus\n              // their state is set to END and when the gesture they are waiting for activates they\n              // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n              // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n              otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n            }\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: GestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      // Order of arguments is correct - we check whether current handler should cancel existing handlers\n\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        this.handlersToCancel.push(otherHandler);\n      }\n    });\n\n    for (let i = this.handlersToCancel.length - 1; i >= 0; --i) {\n      this.handlersToCancel[i]?.cancel();\n    }\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel();\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (this.awaitingHandlers[i] === handler) {\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n\n    this.handlersToCancel = [];\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getView() !== otherHandler.getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: handlerX, y: handlerY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: otherX, y: otherY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: GestureHandler): void {\n    this.gestureHandlers.forEach((handler: GestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.PEN\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}