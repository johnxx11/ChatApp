{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import{EventTypes,MouseButtons,PointerType,TouchEventType}from\"../interfaces\";import EventManager from\"./EventManager\";import{isPointerInBounds}from\"../utils\";var TouchEventManager=function(_EventManager){_inherits(TouchEventManager,_EventManager);var _super=_createSuper(TouchEventManager);function TouchEventManager(){_classCallCheck(this,TouchEventManager);return _super.apply(this,arguments);}_createClass(TouchEventManager,[{key:\"setListeners\",value:function setListeners(){var _this=this;this.view.addEventListener('touchstart',function(event){for(var i=0;i<event.changedTouches.length;++i){var adaptedEvent=_this.mapEvent(event,EventTypes.DOWN,i,TouchEventType.DOWN);if(!isPointerInBounds(_this.view,{x:adaptedEvent.x,y:adaptedEvent.y})||event.changedTouches[i].touchType==='stylus'){continue;}_this.markAsInBounds(adaptedEvent.pointerId);if(++_this.activePointersCounter>1){adaptedEvent.eventType=EventTypes.ADDITIONAL_POINTER_DOWN;_this.onPointerAdd(adaptedEvent);}else{_this.onPointerDown(adaptedEvent);}}});this.view.addEventListener('touchmove',function(event){for(var i=0;i<event.changedTouches.length;++i){var adaptedEvent=_this.mapEvent(event,EventTypes.MOVE,i,TouchEventType.MOVE);if(event.changedTouches[i].touchType==='stylus'){continue;}var inBounds=isPointerInBounds(_this.view,{x:adaptedEvent.x,y:adaptedEvent.y});var pointerIndex=_this.pointersInBounds.indexOf(adaptedEvent.pointerId);if(inBounds){if(pointerIndex<0){adaptedEvent.eventType=EventTypes.ENTER;_this.onPointerEnter(adaptedEvent);_this.markAsInBounds(adaptedEvent.pointerId);}else{_this.onPointerMove(adaptedEvent);}}else{if(pointerIndex>=0){adaptedEvent.eventType=EventTypes.OUT;_this.onPointerOut(adaptedEvent);_this.markAsOutOfBounds(adaptedEvent.pointerId);}else{_this.onPointerOutOfBounds(adaptedEvent);}}}});this.view.addEventListener('touchend',function(event){for(var i=0;i<event.changedTouches.length;++i){if(_this.activePointersCounter===0){break;}if(event.changedTouches[i].touchType==='stylus'){continue;}var adaptedEvent=_this.mapEvent(event,EventTypes.UP,i,TouchEventType.UP);_this.markAsOutOfBounds(adaptedEvent.pointerId);if(--_this.activePointersCounter>0){adaptedEvent.eventType=EventTypes.ADDITIONAL_POINTER_UP;_this.onPointerRemove(adaptedEvent);}else{_this.onPointerUp(adaptedEvent);}}});this.view.addEventListener('touchcancel',function(event){for(var i=0;i<event.changedTouches.length;++i){var adaptedEvent=_this.mapEvent(event,EventTypes.CANCEL,i,TouchEventType.CANCELLED);if(event.changedTouches[i].touchType==='stylus'){continue;}_this.onPointerCancel(adaptedEvent);_this.markAsOutOfBounds(adaptedEvent.pointerId);_this.activePointersCounter=0;}});}},{key:\"mapEvent\",value:function mapEvent(event,eventType,index,touchEventType){var rect=this.view.getBoundingClientRect();var clientX=event.changedTouches[index].clientX;var clientY=event.changedTouches[index].clientY;return{x:clientX,y:clientY,offsetX:clientX-rect.left,offsetY:clientY-rect.top,pointerId:event.changedTouches[index].identifier,eventType:eventType,pointerType:PointerType.TOUCH,buttons:MouseButtons.NONE,time:event.timeStamp,allTouches:event.touches,changedTouches:event.changedTouches,touchEventType:touchEventType};}}]);return TouchEventManager;}(EventManager);export{TouchEventManager as default};","map":{"version":3,"sources":["TouchEventManager.ts"],"names":["setListeners","event","i","adaptedEvent","EventTypes","TouchEventType","isPointerInBounds","x","y","inBounds","pointerIndex","mapEvent","rect","clientX","clientY","offsetX","offsetY","pointerId","eventType","pointerType","PointerType","buttons","MouseButtons","time","allTouches","changedTouches","touchEventType"],"mappings":"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","sourcesContent":["import {\n  AdaptedEvent,\n  EventTypes,\n  MouseButtons,\n  PointerType,\n  TouchEventType,\n} from '../interfaces';\nimport EventManager from './EventManager';\nimport { isPointerInBounds } from '../utils';\n\nexport default class TouchEventManager extends EventManager {\n  public setListeners(): void {\n    this.view.addEventListener('touchstart', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.DOWN,\n          i,\n          TouchEventType.DOWN\n        );\n\n        // Here we skip stylus, because in case of anything different than touch we want to handle it by using PointerEvents\n        // If we leave stylus to send touch events, handlers will receive every action twice\n        if (\n          !isPointerInBounds(this.view, {\n            x: adaptedEvent.x,\n            y: adaptedEvent.y,\n          }) ||\n          //@ts-ignore touchType field does exist\n          event.changedTouches[i].touchType === 'stylus'\n        ) {\n          continue;\n        }\n\n        this.markAsInBounds(adaptedEvent.pointerId);\n\n        if (++this.activePointersCounter > 1) {\n          adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n          this.onPointerAdd(adaptedEvent);\n        } else {\n          this.onPointerDown(adaptedEvent);\n        }\n      }\n    });\n\n    this.view.addEventListener('touchmove', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.MOVE,\n          i,\n          TouchEventType.MOVE\n        );\n        //@ts-ignore touchType field does exist\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n\n        const inBounds: boolean = isPointerInBounds(this.view, {\n          x: adaptedEvent.x,\n          y: adaptedEvent.y,\n        });\n\n        const pointerIndex: number = this.pointersInBounds.indexOf(\n          adaptedEvent.pointerId\n        );\n\n        if (inBounds) {\n          if (pointerIndex < 0) {\n            adaptedEvent.eventType = EventTypes.ENTER;\n            this.onPointerEnter(adaptedEvent);\n            this.markAsInBounds(adaptedEvent.pointerId);\n          } else {\n            this.onPointerMove(adaptedEvent);\n          }\n        } else {\n          if (pointerIndex >= 0) {\n            adaptedEvent.eventType = EventTypes.OUT;\n            this.onPointerOut(adaptedEvent);\n            this.markAsOutOfBounds(adaptedEvent.pointerId);\n          } else {\n            this.onPointerOutOfBounds(adaptedEvent);\n          }\n        }\n      }\n    });\n\n    this.view.addEventListener('touchend', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        // When we call reset on gesture handlers, it also resets their event managers\n        // In some handlers (like RotationGestureHandler) reset is called before all pointers leave view\n        // This means, that activePointersCounter will be set to 0, while there are still remaining pointers on view\n        // Removing them will end in activePointersCounter going below 0, therefore handlers won't behave properly\n        if (this.activePointersCounter === 0) {\n          break;\n        }\n\n        //@ts-ignore touchType field does exist\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.UP,\n          i,\n          TouchEventType.UP\n        );\n\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n\n        if (--this.activePointersCounter > 0) {\n          adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n          this.onPointerRemove(adaptedEvent);\n        } else {\n          this.onPointerUp(adaptedEvent);\n        }\n      }\n    });\n\n    this.view.addEventListener('touchcancel', (event: TouchEvent) => {\n      for (let i = 0; i < event.changedTouches.length; ++i) {\n        const adaptedEvent: AdaptedEvent = this.mapEvent(\n          event,\n          EventTypes.CANCEL,\n          i,\n          TouchEventType.CANCELLED\n        );\n\n        //@ts-ignore touchType field does exist\n        if (event.changedTouches[i].touchType === 'stylus') {\n          continue;\n        }\n\n        this.onPointerCancel(adaptedEvent);\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n        this.activePointersCounter = 0;\n      }\n    });\n  }\n\n  protected mapEvent(\n    event: TouchEvent,\n    eventType: EventTypes,\n    index: number,\n    touchEventType: TouchEventType\n  ): AdaptedEvent {\n    const rect = this.view.getBoundingClientRect();\n    const clientX = event.changedTouches[index].clientX;\n    const clientY = event.changedTouches[index].clientY;\n\n    return {\n      x: clientX,\n      y: clientY,\n      offsetX: clientX - rect.left,\n      offsetY: clientY - rect.top,\n      pointerId: event.changedTouches[index].identifier,\n      eventType: eventType,\n      pointerType: PointerType.TOUCH,\n      buttons: MouseButtons.NONE,\n      time: event.timeStamp,\n      allTouches: event.touches,\n      changedTouches: event.changedTouches,\n      touchEventType: touchEventType,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}