{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import{DEFAULT_TOUCH_SLOP}from\"../constants\";import{EventTypes}from\"../interfaces\";var ScaleGestureDetector=function(){function ScaleGestureDetector(callbacks){_classCallCheck(this,ScaleGestureDetector);_defineProperty(this,\"onScaleBegin\",void 0);_defineProperty(this,\"onScale\",void 0);_defineProperty(this,\"onScaleEnd\",void 0);_defineProperty(this,\"focusX\",void 0);_defineProperty(this,\"focusY\",void 0);_defineProperty(this,\"currentSpan\",void 0);_defineProperty(this,\"prevSpan\",void 0);_defineProperty(this,\"initialSpan\",void 0);_defineProperty(this,\"currentTime\",void 0);_defineProperty(this,\"prevTime\",void 0);_defineProperty(this,\"inProgress\",false);_defineProperty(this,\"spanSlop\",void 0);_defineProperty(this,\"minSpan\",void 0);this.onScaleBegin=callbacks.onScaleBegin;this.onScale=callbacks.onScale;this.onScaleEnd=callbacks.onScaleEnd;this.spanSlop=DEFAULT_TOUCH_SLOP*2;this.minSpan=0;}_createClass(ScaleGestureDetector,[{key:\"onTouchEvent\",value:function onTouchEvent(event,tracker){this.currentTime=event.time;var action=event.eventType;var numOfPointers=tracker.getTrackedPointersCount();var streamComplete=action===EventTypes.UP||action===EventTypes.ADDITIONAL_POINTER_UP||action===EventTypes.CANCEL;if(action===EventTypes.DOWN||streamComplete){if(this.inProgress){this.onScaleEnd(this);this.inProgress=false;this.initialSpan=0;}if(streamComplete){return true;}}var configChanged=action===EventTypes.DOWN||action===EventTypes.ADDITIONAL_POINTER_UP||action===EventTypes.ADDITIONAL_POINTER_DOWN;var pointerUp=action===EventTypes.ADDITIONAL_POINTER_UP;var ignoredPointer=pointerUp?event.pointerId:undefined;var div=pointerUp?numOfPointers-1:numOfPointers;var sumX=tracker.getSumX(ignoredPointer);var sumY=tracker.getSumY(ignoredPointer);var focusX=sumX/div;var focusY=sumY/div;var devSumX=0;var devSumY=0;tracker.getData().forEach(function(value,key){if(key===ignoredPointer){return;}devSumX+=Math.abs(value.lastX-focusX);devSumY+=Math.abs(value.lastY-focusY);});var devX=devSumX/div;var devY=devSumY/div;var spanX=devX*2;var spanY=devY*2;var span=Math.hypot(spanX,spanY);var wasInProgress=this.inProgress;this.focusX=focusX;this.focusY=focusY;if(this.inProgress&&(span<this.minSpan||configChanged)){this.onScaleEnd(this);this.inProgress=false;this.initialSpan=span;}if(configChanged){this.initialSpan=this.prevSpan=this.currentSpan=span;}if(!this.inProgress&&span>=this.minSpan&&(wasInProgress||Math.abs(span-this.initialSpan)>this.spanSlop)){this.prevSpan=this.currentSpan=span;this.prevTime=this.currentTime;this.inProgress=this.onScaleBegin(this);}if(action!==EventTypes.MOVE){return true;}this.currentSpan=span;if(this.inProgress&&!this.onScale(this)){return true;}this.prevSpan=this.currentSpan;this.prevTime=this.currentTime;return true;}},{key:\"getCurrentSpan\",value:function getCurrentSpan(){return this.currentSpan;}},{key:\"getFocusX\",value:function getFocusX(){return this.focusX;}},{key:\"getFocusY\",value:function getFocusY(){return this.focusY;}},{key:\"getTimeDelta\",value:function getTimeDelta(){return this.currentTime-this.prevTime;}},{key:\"getScaleFactor\",value:function getScaleFactor(numOfPointers){if(numOfPointers<2){return 1;}return this.prevSpan>0?this.currentSpan/this.prevSpan:1;}}]);return ScaleGestureDetector;}();export{ScaleGestureDetector as default};","map":{"version":3,"sources":["ScaleGestureDetector.ts"],"names":["constructor","callbacks","DEFAULT_TOUCH_SLOP","onTouchEvent","event","action","numOfPointers","tracker","streamComplete","EventTypes","configChanged","pointerUp","ignoredPointer","div","sumX","sumY","focusX","focusY","devSumX","devSumY","key","Math","value","devX","devY","spanX","spanY","span","wasInProgress","getCurrentSpan","getFocusX","getFocusY","getTimeDelta","getScaleFactor"],"mappings":"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","sourcesContent":["import { DEFAULT_TOUCH_SLOP } from '../constants';\nimport { AdaptedEvent, EventTypes } from '../interfaces';\n\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface ScaleGestureListener {\n  onScaleBegin: (detector: ScaleGestureDetector) => boolean;\n  onScale: (detector: ScaleGestureDetector) => boolean;\n  onScaleEnd: (detector: ScaleGestureDetector) => void;\n}\n\nexport default class ScaleGestureDetector implements ScaleGestureListener {\n  public onScaleBegin: (detector: ScaleGestureDetector) => boolean;\n  public onScale: (detector: ScaleGestureDetector) => boolean;\n  public onScaleEnd: (detector: ScaleGestureDetector) => void;\n\n  private focusX!: number;\n  private focusY!: number;\n\n  private currentSpan!: number;\n  private prevSpan!: number;\n  private initialSpan!: number;\n\n  private currentTime!: number;\n  private prevTime!: number;\n\n  private inProgress = false;\n\n  private spanSlop: number;\n  private minSpan: number;\n\n  public constructor(callbacks: ScaleGestureListener) {\n    this.onScaleBegin = callbacks.onScaleBegin;\n    this.onScale = callbacks.onScale;\n    this.onScaleEnd = callbacks.onScaleEnd;\n\n    this.spanSlop = DEFAULT_TOUCH_SLOP * 2;\n    this.minSpan = 0;\n  }\n\n  public onTouchEvent(event: AdaptedEvent, tracker: PointerTracker): boolean {\n    this.currentTime = event.time;\n\n    const action: EventTypes = event.eventType;\n    const numOfPointers = tracker.getTrackedPointersCount();\n\n    const streamComplete: boolean =\n      action === EventTypes.UP ||\n      action === EventTypes.ADDITIONAL_POINTER_UP ||\n      action === EventTypes.CANCEL;\n\n    if (action === EventTypes.DOWN || streamComplete) {\n      if (this.inProgress) {\n        this.onScaleEnd(this);\n        this.inProgress = false;\n        this.initialSpan = 0;\n      }\n\n      if (streamComplete) {\n        return true;\n      }\n    }\n\n    const configChanged: boolean =\n      action === EventTypes.DOWN ||\n      action === EventTypes.ADDITIONAL_POINTER_UP ||\n      action === EventTypes.ADDITIONAL_POINTER_DOWN;\n\n    const pointerUp = action === EventTypes.ADDITIONAL_POINTER_UP;\n\n    const ignoredPointer: number | undefined = pointerUp\n      ? event.pointerId\n      : undefined;\n\n    //Determine focal point\n\n    const div: number = pointerUp ? numOfPointers - 1 : numOfPointers;\n\n    const sumX = tracker.getSumX(ignoredPointer);\n    const sumY = tracker.getSumY(ignoredPointer);\n\n    const focusX = sumX / div;\n    const focusY = sumY / div;\n\n    //Determine average deviation from focal point\n\n    let devSumX = 0;\n    let devSumY = 0;\n\n    tracker.getData().forEach((value, key) => {\n      if (key === ignoredPointer) {\n        return;\n      }\n\n      devSumX += Math.abs(value.lastX - focusX);\n      devSumY += Math.abs(value.lastY - focusY);\n    });\n\n    const devX: number = devSumX / div;\n    const devY: number = devSumY / div;\n\n    const spanX: number = devX * 2;\n    const spanY: number = devY * 2;\n\n    const span = Math.hypot(spanX, spanY);\n\n    //Begin/end events\n    const wasInProgress: boolean = this.inProgress;\n    this.focusX = focusX;\n    this.focusY = focusY;\n\n    if (this.inProgress && (span < this.minSpan || configChanged)) {\n      this.onScaleEnd(this);\n      this.inProgress = false;\n      this.initialSpan = span;\n    }\n\n    if (configChanged) {\n      this.initialSpan = this.prevSpan = this.currentSpan = span;\n    }\n\n    if (\n      !this.inProgress &&\n      span >= this.minSpan &&\n      (wasInProgress || Math.abs(span - this.initialSpan) > this.spanSlop)\n    ) {\n      this.prevSpan = this.currentSpan = span;\n      this.prevTime = this.currentTime;\n      this.inProgress = this.onScaleBegin(this);\n    }\n\n    //Handle motion\n    if (action !== EventTypes.MOVE) {\n      return true;\n    }\n\n    this.currentSpan = span;\n\n    if (this.inProgress && !this.onScale(this)) {\n      return true;\n    }\n\n    this.prevSpan = this.currentSpan;\n    this.prevTime = this.currentTime;\n\n    return true;\n  }\n\n  public getCurrentSpan(): number {\n    return this.currentSpan;\n  }\n\n  public getFocusX(): number {\n    return this.focusX;\n  }\n\n  public getFocusY(): number {\n    return this.focusY;\n  }\n\n  public getTimeDelta(): number {\n    return this.currentTime - this.prevTime;\n  }\n\n  public getScaleFactor(numOfPointers: number): number {\n    if (numOfPointers < 2) {\n      return 1;\n    }\n\n    return this.prevSpan > 0 ? this.currentSpan / this.prevSpan : 1;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}