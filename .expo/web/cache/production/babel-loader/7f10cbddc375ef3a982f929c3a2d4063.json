{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var EventManager=function(){function EventManager(view){_classCallCheck(this,EventManager);_defineProperty(this,\"view\",void 0);_defineProperty(this,\"pointersInBounds\",[]);_defineProperty(this,\"activePointersCounter\",void 0);this.view=view;this.activePointersCounter=0;}_createClass(EventManager,[{key:\"onPointerDown\",value:function onPointerDown(_event){}},{key:\"onPointerAdd\",value:function onPointerAdd(_event){}},{key:\"onPointerUp\",value:function onPointerUp(_event){}},{key:\"onPointerRemove\",value:function onPointerRemove(_event){}},{key:\"onPointerMove\",value:function onPointerMove(_event){}},{key:\"onPointerOut\",value:function onPointerOut(_event){}},{key:\"onPointerEnter\",value:function onPointerEnter(_event){}},{key:\"onPointerCancel\",value:function onPointerCancel(_event){}},{key:\"onPointerOutOfBounds\",value:function onPointerOutOfBounds(_event){}},{key:\"setOnPointerDown\",value:function setOnPointerDown(callback){this.onPointerDown=callback;}},{key:\"setOnPointerAdd\",value:function setOnPointerAdd(callback){this.onPointerAdd=callback;}},{key:\"setOnPointerUp\",value:function setOnPointerUp(callback){this.onPointerUp=callback;}},{key:\"setOnPointerRemove\",value:function setOnPointerRemove(callback){this.onPointerRemove=callback;}},{key:\"setOnPointerMove\",value:function setOnPointerMove(callback){this.onPointerMove=callback;}},{key:\"setOnPointerOut\",value:function setOnPointerOut(callback){this.onPointerOut=callback;}},{key:\"setOnPointerEnter\",value:function setOnPointerEnter(callback){this.onPointerEnter=callback;}},{key:\"setOnPointerCancel\",value:function setOnPointerCancel(callback){this.onPointerCancel=callback;}},{key:\"setOnPointerOutOfBounds\",value:function setOnPointerOutOfBounds(callback){this.onPointerOutOfBounds=callback;}},{key:\"markAsInBounds\",value:function markAsInBounds(pointerId){if(this.pointersInBounds.indexOf(pointerId)>=0){return;}this.pointersInBounds.push(pointerId);}},{key:\"markAsOutOfBounds\",value:function markAsOutOfBounds(pointerId){var index=this.pointersInBounds.indexOf(pointerId);if(index<0){return;}this.pointersInBounds.splice(index,1);}},{key:\"resetManager\",value:function resetManager(){this.activePointersCounter=0;this.pointersInBounds=[];}}]);return EventManager;}();export{EventManager as default};","map":{"version":3,"sources":["EventManager.ts"],"names":["constructor","onPointerDown","onPointerAdd","onPointerUp","onPointerRemove","onPointerMove","onPointerOut","onPointerEnter","onPointerCancel","onPointerOutOfBounds","setOnPointerDown","setOnPointerAdd","setOnPointerUp","setOnPointerRemove","setOnPointerMove","setOnPointerOut","setOnPointerEnter","setOnPointerCancel","setOnPointerOutOfBounds","markAsInBounds","markAsOutOfBounds","index","resetManager"],"mappings":"yTAGe,a,YAKbA,sBAAW,IAAXA,CAA+B,oCAAA,eAAA,CAAA,IAAA,CAAA,MAAA,CAAA,IAAA,EAAA,CAAA,CAAA,eAAA,CAAA,IAAA,CAAA,kBAAA,CAHQ,EAGR,CAAA,CAAA,eAAA,CAAA,IAAA,CAAA,uBAAA,CAAA,IAAA,EAAA,CAAA,CAC7B,KAAA,IAAA,CAAA,IAAA,CACA,KAAA,qBAAA,CAAA,CAAA,CACD,C,sDAUSC,uBAAa,MAAbA,CAA0C,CAAE,C,4BAC5CC,sBAAY,MAAZA,CAAyC,CAAE,C,2BAC3CC,qBAAW,MAAXA,CAAwC,CAAE,C,+BAC1CC,yBAAe,MAAfA,CAA4C,CAAE,C,6BAC9CC,uBAAa,MAAbA,CAA0C,CAAE,C,4BAC5CC,sBAAY,MAAZA,CAAyC,CAAE,C,8BAC3CC,wBAAc,MAAdA,CAA2C,CAAE,C,+BAC7CC,yBAAe,MAAfA,CAA4C,CAKrD,C,oCACSC,8BAAoB,MAApBA,CAAiD,CAAE,C,gCAEtDC,0BAAgB,QAAhBA,CAAgE,CACrE,KAAA,aAAA,CAAA,QAAA,CACD,C,+BACMC,yBAAe,QAAfA,CAA+D,CACpE,KAAA,YAAA,CAAA,QAAA,CACD,C,8BACMC,wBAAc,QAAdA,CAA8D,CACnE,KAAA,WAAA,CAAA,QAAA,CACD,C,kCACMC,4BAAkB,QAAlBA,CAAkE,CACvE,KAAA,eAAA,CAAA,QAAA,CACD,C,gCACMC,0BAAgB,QAAhBA,CAAgE,CACrE,KAAA,aAAA,CAAA,QAAA,CACD,C,+BACMC,yBAAe,QAAfA,CAA+D,CACpE,KAAA,YAAA,CAAA,QAAA,CACD,C,iCACMC,2BAAiB,QAAjBA,CAAiE,CACtE,KAAA,cAAA,CAAA,QAAA,CACD,C,kCACMC,4BAAkB,QAAlBA,CAAkE,CACvE,KAAA,eAAA,CAAA,QAAA,CACD,C,uCACMC,iCAAuB,QAAvBA,CAEC,CACN,KAAA,oBAAA,CAAA,QAAA,CACD,C,8BAESC,wBAAc,SAAdA,CAAwC,CAChD,GAAI,KAAA,gBAAA,CAAA,OAAA,CAAA,SAAA,GAAJ,CAAA,CAAmD,CACjD,OACD,CAED,KAAA,gBAAA,CAAA,IAAA,CAAA,SAAA,EACD,C,iCAESC,2BAAiB,SAAjBA,CAA2C,CACnD,GAAMC,MAAa,CAAG,KAAA,gBAAA,CAAA,OAAA,CAAtB,SAAsB,CAAtB,CAEA,GAAIA,KAAK,CAAT,CAAA,CAAe,CACb,OACD,CAED,KAAA,gBAAA,CAAA,MAAA,CAAA,KAAA,CAAA,CAAA,EACD,C,4BAEMC,uBAAqB,CAQ1B,KAAA,qBAAA,CAAA,CAAA,CACA,KAAA,gBAAA,CAAA,EAAA,CACD,C,mCA3FY,Y","sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { AdaptedEvent, EventTypes, TouchEventType } from '../interfaces';\n\nexport default abstract class EventManager {\n  protected readonly view: HTMLElement;\n  protected pointersInBounds: number[] = [];\n  protected activePointersCounter: number;\n\n  constructor(view: HTMLElement) {\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n\n  public abstract setListeners(): void;\n  protected abstract mapEvent(\n    event: Event,\n    eventType: EventTypes,\n    index?: number,\n    touchEventType?: TouchEventType\n  ): AdaptedEvent;\n\n  protected onPointerDown(_event: AdaptedEvent): void {}\n  protected onPointerAdd(_event: AdaptedEvent): void {}\n  protected onPointerUp(_event: AdaptedEvent): void {}\n  protected onPointerRemove(_event: AdaptedEvent): void {}\n  protected onPointerMove(_event: AdaptedEvent): void {}\n  protected onPointerOut(_event: AdaptedEvent): void {}\n  protected onPointerEnter(_event: AdaptedEvent): void {}\n  protected onPointerCancel(_event: AdaptedEvent): void {\n    // When pointer cancel is triggered and there are more pointers on the view, only one pointer is cancelled\n    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0\n    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter\n    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled\n  }\n  protected onPointerOutOfBounds(_event: AdaptedEvent): void {}\n\n  public setOnPointerDown(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerDown = callback;\n  }\n  public setOnPointerAdd(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerAdd = callback;\n  }\n  public setOnPointerUp(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerUp = callback;\n  }\n  public setOnPointerRemove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerRemove = callback;\n  }\n  public setOnPointerMove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMove = callback;\n  }\n  public setOnPointerOut(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerOut = callback;\n  }\n  public setOnPointerEnter(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerEnter = callback;\n  }\n  public setOnPointerCancel(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerCancel = callback;\n  }\n  public setOnPointerOutOfBounds(\n    callback: (event: AdaptedEvent) => void\n  ): void {\n    this.onPointerOutOfBounds = callback;\n  }\n\n  protected markAsInBounds(pointerId: number): void {\n    if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n      return;\n    }\n\n    this.pointersInBounds.push(pointerId);\n  }\n\n  protected markAsOutOfBounds(pointerId: number): void {\n    const index: number = this.pointersInBounds.indexOf(pointerId);\n\n    if (index < 0) {\n      return;\n    }\n\n    this.pointersInBounds.splice(index, 1);\n  }\n\n  public resetManager(): void {\n    // Reseting activePointersCounter is necessary to make gestures such as pinch work properly\n    // There are gestures that end when there is still one active pointer (like pinch/rotation)\n    // When these gestures end, they are reset, but they still receive events from pointer that is active\n    // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive\n    // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one\n    // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED\n\n    this.activePointersCounter = 0;\n    this.pointersInBounds = [];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}