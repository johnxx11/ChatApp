{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import{EventTypes,MouseButtons,PointerType}from\"../interfaces\";import EventManager from\"./EventManager\";import{isPointerInBounds}from\"../utils\";var PointerEventManager=function(_EventManager){_inherits(PointerEventManager,_EventManager);var _super=_createSuper(PointerEventManager);function PointerEventManager(){_classCallCheck(this,PointerEventManager);return _super.apply(this,arguments);}_createClass(PointerEventManager,[{key:\"setListeners\",value:function setListeners(){var _this=this;this.view.addEventListener('pointerdown',function(event){if(event.pointerType===PointerType.TOUCH){return;}if(!isPointerInBounds(_this.view,{x:event.clientX,y:event.clientY})){return;}var adaptedEvent=_this.mapEvent(event,EventTypes.DOWN);var target=event.target;target.setPointerCapture(adaptedEvent.pointerId);_this.markAsInBounds(adaptedEvent.pointerId);if(++_this.activePointersCounter>1){adaptedEvent.eventType=EventTypes.ADDITIONAL_POINTER_DOWN;_this.onPointerAdd(adaptedEvent);}else{_this.onPointerDown(adaptedEvent);}});this.view.addEventListener('pointerup',function(event){if(event.pointerType===PointerType.TOUCH){return;}if(_this.activePointersCounter===0){return;}var adaptedEvent=_this.mapEvent(event,EventTypes.UP);var target=event.target;target.releasePointerCapture(adaptedEvent.pointerId);_this.markAsOutOfBounds(adaptedEvent.pointerId);if(--_this.activePointersCounter>0){adaptedEvent.eventType=EventTypes.ADDITIONAL_POINTER_UP;_this.onPointerRemove(adaptedEvent);}else{_this.onPointerUp(adaptedEvent);}});this.view.addEventListener('pointermove',function(event){if(event.pointerType===PointerType.TOUCH){return;}if(event.pointerType===PointerType.MOUSE&&event.buttons!==MouseButtons.LEFT){return;}var adaptedEvent=_this.mapEvent(event,EventTypes.MOVE);var inBounds=isPointerInBounds(_this.view,{x:adaptedEvent.x,y:adaptedEvent.y});var pointerIndex=_this.pointersInBounds.indexOf(adaptedEvent.pointerId);if(inBounds){if(pointerIndex<0){adaptedEvent.eventType=EventTypes.ENTER;_this.onPointerEnter(adaptedEvent);_this.markAsInBounds(adaptedEvent.pointerId);}else{_this.onPointerMove(adaptedEvent);}}else{if(pointerIndex>=0){adaptedEvent.eventType=EventTypes.OUT;_this.onPointerOut(adaptedEvent);_this.markAsOutOfBounds(adaptedEvent.pointerId);}else{_this.onPointerOutOfBounds(adaptedEvent);}}});this.view.addEventListener('pointercancel',function(event){if(event.pointerType===PointerType.TOUCH){return;}var adaptedEvent=_this.mapEvent(event,EventTypes.CANCEL);_this.onPointerCancel(adaptedEvent);_this.markAsOutOfBounds(adaptedEvent.pointerId);_this.activePointersCounter=0;});}},{key:\"mapEvent\",value:function mapEvent(event,eventType){return{x:event.clientX,y:event.clientY,offsetX:event.offsetX,offsetY:event.offsetY,pointerId:event.pointerId,eventType:eventType,pointerType:event.pointerType,buttons:event.buttons,time:event.timeStamp};}}]);return PointerEventManager;}(EventManager);export{PointerEventManager as default};","map":{"version":3,"sources":["PointerEventManager.ts"],"names":["setListeners","event","PointerType","isPointerInBounds","x","y","clientY","adaptedEvent","EventTypes","target","MouseButtons","inBounds","pointerIndex","mapEvent","offsetX","offsetY","pointerId","eventType","pointerType","buttons","time","timeStamp"],"mappings":"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","sourcesContent":["import {\n  AdaptedEvent,\n  EventTypes,\n  MouseButtons,\n  PointerType,\n} from '../interfaces';\nimport EventManager from './EventManager';\nimport { isPointerInBounds } from '../utils';\n\nexport default class PointerEventManager extends EventManager {\n  public setListeners(): void {\n    this.view.addEventListener('pointerdown', (event: PointerEvent): void => {\n      if (event.pointerType === PointerType.TOUCH) {\n        return;\n      }\n      if (\n        !isPointerInBounds(this.view, { x: event.clientX, y: event.clientY })\n      ) {\n        return;\n      }\n\n      const adaptedEvent: AdaptedEvent = this.mapEvent(event, EventTypes.DOWN);\n      const target = event.target as HTMLElement;\n\n      target.setPointerCapture(adaptedEvent.pointerId);\n      this.markAsInBounds(adaptedEvent.pointerId);\n\n      if (++this.activePointersCounter > 1) {\n        adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n        this.onPointerAdd(adaptedEvent);\n      } else {\n        this.onPointerDown(adaptedEvent);\n      }\n    });\n\n    this.view.addEventListener('pointerup', (event: PointerEvent): void => {\n      if (event.pointerType === PointerType.TOUCH) {\n        return;\n      }\n\n      // When we call reset on gesture handlers, it also resets their event managers\n      // In some handlers (like RotationGestureHandler) reset is called before all pointers leave view\n      // This means, that activePointersCounter will be set to 0, while there are still remaining pointers on view\n      // Removing them will end in activePointersCounter going below 0, therefore handlers won't behave properly\n      if (this.activePointersCounter === 0) {\n        return;\n      }\n\n      const adaptedEvent: AdaptedEvent = this.mapEvent(event, EventTypes.UP);\n      const target = event.target as HTMLElement;\n\n      target.releasePointerCapture(adaptedEvent.pointerId);\n      this.markAsOutOfBounds(adaptedEvent.pointerId);\n\n      if (--this.activePointersCounter > 0) {\n        adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n        this.onPointerRemove(adaptedEvent);\n      } else {\n        this.onPointerUp(adaptedEvent);\n      }\n    });\n\n    this.view.addEventListener('pointermove', (event: PointerEvent): void => {\n      if (event.pointerType === PointerType.TOUCH) {\n        return;\n      }\n\n      if (\n        event.pointerType === PointerType.MOUSE &&\n        event.buttons !== MouseButtons.LEFT\n      ) {\n        return;\n      }\n\n      const adaptedEvent: AdaptedEvent = this.mapEvent(event, EventTypes.MOVE);\n\n      const inBounds: boolean = isPointerInBounds(this.view, {\n        x: adaptedEvent.x,\n        y: adaptedEvent.y,\n      });\n\n      const pointerIndex: number = this.pointersInBounds.indexOf(\n        adaptedEvent.pointerId\n      );\n\n      if (inBounds) {\n        if (pointerIndex < 0) {\n          adaptedEvent.eventType = EventTypes.ENTER;\n          this.onPointerEnter(adaptedEvent);\n          this.markAsInBounds(adaptedEvent.pointerId);\n        } else {\n          this.onPointerMove(adaptedEvent);\n        }\n      } else {\n        if (pointerIndex >= 0) {\n          adaptedEvent.eventType = EventTypes.OUT;\n          this.onPointerOut(adaptedEvent);\n          this.markAsOutOfBounds(adaptedEvent.pointerId);\n        } else {\n          this.onPointerOutOfBounds(adaptedEvent);\n        }\n      }\n    });\n\n    this.view.addEventListener('pointercancel', (event: PointerEvent): void => {\n      if (event.pointerType === PointerType.TOUCH) {\n        return;\n      }\n\n      const adaptedEvent: AdaptedEvent = this.mapEvent(\n        event,\n        EventTypes.CANCEL\n      );\n\n      this.onPointerCancel(adaptedEvent);\n      this.markAsOutOfBounds(adaptedEvent.pointerId);\n      this.activePointersCounter = 0;\n    });\n  }\n\n  protected mapEvent(event: PointerEvent, eventType: EventTypes): AdaptedEvent {\n    return {\n      x: event.clientX,\n      y: event.clientY,\n      offsetX: event.offsetX,\n      offsetY: event.offsetY,\n      pointerId: event.pointerId,\n      eventType: eventType,\n      pointerType: event.pointerType as PointerType,\n      buttons: event.buttons,\n      time: event.timeStamp,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}