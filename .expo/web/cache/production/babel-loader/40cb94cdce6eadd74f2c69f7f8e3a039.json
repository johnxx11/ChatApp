{"ast":null,"code":"import*as React from'react';import NavigationBuilderContext from\"./NavigationBuilderContext\";import useOnPreventRemove,{shouldPreventRemove}from\"./useOnPreventRemove\";export default function useOnAction(_ref){var router=_ref.router,getState=_ref.getState,setState=_ref.setState,key=_ref.key,actionListeners=_ref.actionListeners,beforeRemoveListeners=_ref.beforeRemoveListeners,routerConfigOptions=_ref.routerConfigOptions,emitter=_ref.emitter;var _React$useContext=React.useContext(NavigationBuilderContext),onActionParent=_React$useContext.onAction,onRouteFocusParent=_React$useContext.onRouteFocus,addListenerParent=_React$useContext.addListener,onDispatchAction=_React$useContext.onDispatchAction;var routerConfigOptionsRef=React.useRef(routerConfigOptions);React.useEffect(function(){routerConfigOptionsRef.current=routerConfigOptions;});var onAction=React.useCallback(function(action){var visitedNavigators=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Set();var state=getState();if(visitedNavigators.has(state.key)){return false;}visitedNavigators.add(state.key);if(typeof action.target!=='string'||action.target===state.key){var result=router.getStateForAction(state,action,routerConfigOptionsRef.current);result=result===null&&action.target===state.key?state:result;if(result!==null){onDispatchAction(action,state===result);if(state!==result){var isPrevented=shouldPreventRemove(emitter,beforeRemoveListeners,state.routes,result.routes,action);if(isPrevented){return true;}setState(result);}if(onRouteFocusParent!==undefined){var shouldFocus=router.shouldActionChangeFocus(action);if(shouldFocus&&key!==undefined){onRouteFocusParent(key);}}return true;}}if(onActionParent!==undefined){if(onActionParent(action,visitedNavigators)){return true;}}for(var i=actionListeners.length-1;i>=0;i--){var listener=actionListeners[i];if(listener(action,visitedNavigators)){return true;}}return false;},[actionListeners,beforeRemoveListeners,emitter,getState,key,onActionParent,onDispatchAction,onRouteFocusParent,router,setState]);useOnPreventRemove({getState:getState,emitter:emitter,beforeRemoveListeners:beforeRemoveListeners});React.useEffect(function(){return addListenerParent===null||addListenerParent===void 0?void 0:addListenerParent('action',onAction);},[addListenerParent,onAction]);return onAction;}","map":{"version":3,"sources":["useOnAction.tsx"],"names":["React","NavigationBuilderContext","useOnPreventRemove","shouldPreventRemove","useOnAction","router","getState","setState","key","actionListeners","beforeRemoveListeners","routerConfigOptions","emitter","onAction","onActionParent","onRouteFocus","onRouteFocusParent","addListener","addListenerParent","onDispatchAction","useContext","routerConfigOptionsRef","useRef","useEffect","current","useCallback","action","visitedNavigators","Set","state","has","add","target","result","getStateForAction","isPrevented","routes","undefined","shouldFocus","shouldActionChangeFocus","i","length","listener"],"mappings":"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","sourceRoot":"../../src","sourcesContent":["import * as React from 'react';\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport useOnPreventRemove, { shouldPreventRemove } from './useOnPreventRemove';\n/**\n * Hook to handle actions for a navigator, including state updates and bubbling.\n *\n * Bubbling an action is achieved in 2 ways:\n * 1. To bubble action to parent, we expose the action handler in context and then access the parent context\n * 2. To bubble action to child, child adds event listeners subscribing to actions from parent\n *\n * When the action handler handles as action, it returns `true`, otherwise `false`.\n */\nexport default function useOnAction(_ref) {\n  let {\n    router,\n    getState,\n    setState,\n    key,\n    actionListeners,\n    beforeRemoveListeners,\n    routerConfigOptions,\n    emitter\n  } = _ref;\n  const {\n    onAction: onActionParent,\n    onRouteFocus: onRouteFocusParent,\n    addListener: addListenerParent,\n    onDispatchAction\n  } = React.useContext(NavigationBuilderContext);\n  const routerConfigOptionsRef = React.useRef(routerConfigOptions);\n  React.useEffect(() => {\n    routerConfigOptionsRef.current = routerConfigOptions;\n  });\n  const onAction = React.useCallback(function (action) {\n    let visitedNavigators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    const state = getState();\n\n    // Since actions can bubble both up and down, they could come to the same navigator again\n    // We keep track of navigators which have already tried to handle the action and return if it's already visited\n    if (visitedNavigators.has(state.key)) {\n      return false;\n    }\n    visitedNavigators.add(state.key);\n    if (typeof action.target !== 'string' || action.target === state.key) {\n      let result = router.getStateForAction(state, action, routerConfigOptionsRef.current);\n\n      // If a target is specified and set to current navigator, the action shouldn't bubble\n      // So instead of `null`, we use the state object for such cases to signal that action was handled\n      result = result === null && action.target === state.key ? state : result;\n      if (result !== null) {\n        onDispatchAction(action, state === result);\n        if (state !== result) {\n          const isPrevented = shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, result.routes, action);\n          if (isPrevented) {\n            return true;\n          }\n          setState(result);\n        }\n        if (onRouteFocusParent !== undefined) {\n          // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree\n          // This means we need to focus all of the parent navigators of this navigator as well\n          const shouldFocus = router.shouldActionChangeFocus(action);\n          if (shouldFocus && key !== undefined) {\n            onRouteFocusParent(key);\n          }\n        }\n        return true;\n      }\n    }\n    if (onActionParent !== undefined) {\n      // Bubble action to the parent if the current navigator didn't handle it\n      if (onActionParent(action, visitedNavigators)) {\n        return true;\n      }\n    }\n\n    // If the action wasn't handled by current navigator or a parent navigator, let children handle it\n    for (let i = actionListeners.length - 1; i >= 0; i--) {\n      const listener = actionListeners[i];\n      if (listener(action, visitedNavigators)) {\n        return true;\n      }\n    }\n    return false;\n  }, [actionListeners, beforeRemoveListeners, emitter, getState, key, onActionParent, onDispatchAction, onRouteFocusParent, router, setState]);\n  useOnPreventRemove({\n    getState,\n    emitter,\n    beforeRemoveListeners\n  });\n  React.useEffect(() => addListenerParent === null || addListenerParent === void 0 ? void 0 : addListenerParent('action', onAction), [addListenerParent, onAction]);\n  return onAction;\n}\n//# sourceMappingURL=useOnAction.js.map"]},"metadata":{},"sourceType":"module"}