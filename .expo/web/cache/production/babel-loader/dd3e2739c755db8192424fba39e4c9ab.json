{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var InteractionManager=function(){function InteractionManager(){_classCallCheck(this,InteractionManager);_defineProperty(this,\"waitForRelations\",new Map());_defineProperty(this,\"simultaneousRelations\",new Map());}_createClass(InteractionManager,[{key:\"configureInteractions\",value:function configureInteractions(handler,config){this.dropRelationsForHandlerWithTag(handler.getTag());if(config.waitFor){var waitFor=[];config.waitFor.forEach(function(otherHandler){if(typeof otherHandler==='number'){waitFor.push(otherHandler);}else{waitFor.push(otherHandler.handlerTag);}});this.waitForRelations.set(handler.getTag(),waitFor);}if(config.simultaneousHandlers){var simultaneousHandlers=[];config.simultaneousHandlers.forEach(function(otherHandler){if(typeof otherHandler==='number'){simultaneousHandlers.push(otherHandler);}else{simultaneousHandlers.push(otherHandler.handlerTag);}});this.simultaneousRelations.set(handler.getTag(),simultaneousHandlers);}}},{key:\"shouldWaitForHandlerFailure\",value:function shouldWaitForHandlerFailure(handler,otherHandler){var waitFor=this.waitForRelations.get(handler.getTag());if(!waitFor){return false;}var shouldWait=false;waitFor.forEach(function(tag){if(tag===otherHandler.getTag()){shouldWait=true;return;}});return shouldWait;}},{key:\"shouldRecognizeSimultaneously\",value:function shouldRecognizeSimultaneously(handler,otherHandler){var simultaneousHandlers=this.simultaneousRelations.get(handler.getTag());if(!simultaneousHandlers){return false;}var shouldRecognizeSimultaneously=false;simultaneousHandlers.forEach(function(tag){if(tag===otherHandler.getTag()){shouldRecognizeSimultaneously=true;return;}});return shouldRecognizeSimultaneously;}},{key:\"shouldRequireHandlerToWaitForFailure\",value:function shouldRequireHandlerToWaitForFailure(_handler,_otherHandler){return false;}},{key:\"shouldHandlerBeCancelledBy\",value:function shouldHandlerBeCancelledBy(_handler,_otherHandler){return false;}},{key:\"dropRelationsForHandlerWithTag\",value:function dropRelationsForHandlerWithTag(handlerTag){this.waitForRelations.delete(handlerTag);this.simultaneousRelations.delete(handlerTag);}},{key:\"reset\",value:function reset(){this.waitForRelations.clear();this.simultaneousRelations.clear();}}],[{key:\"getInstance\",value:function getInstance(){if(!this.instance){this.instance=new InteractionManager();}return this.instance;}}]);return InteractionManager;}();export{InteractionManager as default};_defineProperty(InteractionManager,\"instance\",void 0);","map":{"version":3,"sources":["InteractionManager.ts"],"names":["InteractionManager","constructor","configureInteractions","handler","config","waitFor","otherHandler","simultaneousHandlers","shouldWaitForHandlerFailure","shouldWait","tag","shouldRecognizeSimultaneously","shouldRequireHandlerToWaitForFailure","shouldHandlerBeCancelledBy","dropRelationsForHandlerWithTag","reset","getInstance"],"mappings":"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","sourcesContent":["import GestureHandler from '../handlers/GestureHandler';\nimport { Config, Handler } from '../interfaces';\n\nexport default class InteractionManager {\n  private static instance: InteractionManager;\n  private readonly waitForRelations: Map<number, number[]> = new Map();\n  private readonly simultaneousRelations: Map<number, number[]> = new Map();\n\n  // Private becaues of singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  public configureInteractions(handler: GestureHandler, config: Config) {\n    this.dropRelationsForHandlerWithTag(handler.getTag());\n\n    if (config.waitFor) {\n      const waitFor: number[] = [];\n      config.waitFor.forEach((otherHandler: Handler): void => {\n        // New API reference\n        if (typeof otherHandler === 'number') {\n          waitFor.push(otherHandler);\n        } else {\n          // Old API reference\n          waitFor.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.waitForRelations.set(handler.getTag(), waitFor);\n    }\n\n    if (config.simultaneousHandlers) {\n      const simultaneousHandlers: number[] = [];\n      config.simultaneousHandlers.forEach((otherHandler: Handler): void => {\n        if (typeof otherHandler === 'number') {\n          simultaneousHandlers.push(otherHandler);\n        } else {\n          simultaneousHandlers.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);\n    }\n  }\n\n  public shouldWaitForHandlerFailure(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const waitFor: number[] | undefined = this.waitForRelations.get(\n      handler.getTag()\n    );\n    if (!waitFor) {\n      return false;\n    }\n\n    let shouldWait = false;\n\n    waitFor.forEach((tag: number): void => {\n      if (tag === otherHandler.getTag()) {\n        shouldWait = true;\n        return; //Returns from callback\n      }\n    });\n\n    return shouldWait;\n  }\n\n  public shouldRecognizeSimultaneously(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const simultaneousHandlers: number[] | undefined =\n      this.simultaneousRelations.get(handler.getTag());\n    if (!simultaneousHandlers) {\n      return false;\n    }\n\n    let shouldRecognizeSimultaneously = false;\n\n    simultaneousHandlers.forEach((tag: number): void => {\n      if (tag === otherHandler.getTag()) {\n        shouldRecognizeSimultaneously = true;\n        return;\n      }\n    });\n\n    return shouldRecognizeSimultaneously;\n  }\n\n  public shouldRequireHandlerToWaitForFailure(\n    _handler: GestureHandler,\n    _otherHandler: GestureHandler\n  ): boolean {\n    //TODO: Implement logic\n    return false;\n  }\n\n  public shouldHandlerBeCancelledBy(\n    _handler: GestureHandler,\n    _otherHandler: GestureHandler\n  ): boolean {\n    //TODO: Implement logic\n    return false;\n  }\n\n  public dropRelationsForHandlerWithTag(handlerTag: number): void {\n    this.waitForRelations.delete(handlerTag);\n    this.simultaneousRelations.delete(handlerTag);\n  }\n\n  public reset() {\n    this.waitForRelations.clear();\n    this.simultaneousRelations.clear();\n  }\n\n  public static getInstance(): InteractionManager {\n    if (!this.instance) {\n      this.instance = new InteractionManager();\n    }\n\n    return this.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}